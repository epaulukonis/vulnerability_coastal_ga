install.packages('corrplot')
library(spatialEco)
library(AICcmodavg)
library(SDMTools)
library(ROCR)
library(raster)
library(rgdal)
library(lme4)
library(corrplot)
library(ggplot2)
library(dismo)
library(caret)
library(tidyverse)

#testing fragstats/models
#plus model validation

#American Oystercatcher
#distance to urbanization
setwd("E:\\FinalModels\\Predictors\\AOC\\urbanization\\distance\\fin")
urb100<-raster("urb100mf")
urb1km<-raster("urb1kmf")
plot(urb100)
plot(urb1km)
#distance to open water
setwd("E:\\FinalModels\\Predictors\\AOC\\openwater\\distance\\fin")
openw100<-raster("ow100mf")
openw1km<-raster("ow1kmf")
plot(openw100)
plot(openw1km)
#elevation
setwd("E:\\FinalModels\\Predictors\\AOC\\elevation\\neighborhood\\fin")
elev100m<-raster("elev100mf")
elev1km<-raster("elev1kmf")
plot(elev100m)
plot(elev1km)
#open beach
setwd("E:\\FinalModels\\Predictors\\AOC\\beachflat")
beachbase<-raster("beachbase")
plot(beachbase)
#marsh
setwd("E:\\FinalModels\\Predictors\\AOC\\marsh")
marshbase<-raster("marshbase")
plot(marshbase)


#read in P/A points
AOC<-readOGR(dsn="E:\\IALE\\all_GA_species\\AOC\\AOCdata\\finalsum2019\\aoc.finpoints.shp")
points(AOC)
AOC@data$PA[is.na(AOC@data$PA)]<-0

#OK so...spatialEco is not capable of doing what we want
#so I'm gonna stick to original plan
#and assign zeroes to NAs for now
#as Cody did previously

#calculate fragstats metrics for marsh, 100m
marshmet100m<-land.metrics(x=AOC, y=marshbase, bw=100, bkgd = 0, echo = TRUE, metrics = 
                      c("prop.landscape","edge.density"))
View(marshmet100m)
marshmet100m<-as.data.frame(marshmet100m[,2:3])
marshmet100m[is.na(marshmet100m)]<-0


######### edit 8/25 1 km is too large for ED; proplandscape likely ok
#calculate fragstats metrics for marsh, 1km
marshmet1km<-land.metrics(x=AOC, y=marshbase, bw=1000, bkgd = 0, echo = TRUE, metrics = 
                             c("prop.landscape"))
View(marshmet1km)
marshmet1km<-as.data.frame(marshmet1km[,2])
marshmet1km[is.na(marshmet1km)]<-0


#calculate fragstats metrics for beach, 100m
beachmet100m<-land.metrics(x=AOC, y=beachbase, bw=100, bkgd = 0, echo = TRUE, metrics = 
                         c("prop.landscape","mean.patch.area", "n.patches"))
View(beachmet100m)


beachmet100m<-as.data.frame(beachmet100m[,2:4])
beachmet100m[is.na(beachmet100m)]<-0


#calculate fragstats metrics for beach, 1km
beachmet1km<-land.metrics(x=AOC, y=beachbase, bw=1000, bkgd = 0, echo = TRUE, metrics = 
                         c("prop.landscape","mean.patch.area", "n.patches"))
View(beachmet1km)
beachmet1km<-as.data.frame(beachmet1km[,2:4])
beachmet1km[is.na(beachmet1km)]<-0


#Append values to the points
AOC@data = data.frame(AOC@data, marshmet100m[match(rownames(AOC@data), rownames(marshmet100m)),])
AOC@data = data.frame(AOC@data, marshmet1km[match(rownames(AOC@data), rownames(marshmet1km)),])
AOC@data = data.frame(AOC@data, beachmet100m[match(rownames(AOC@data), rownames(beachmet100m)),])
AOC@data = data.frame(AOC@data, beachmet1km[match(rownames(AOC@data), rownames(beachmet1km)),])
View(AOC@data)

#AOC@data <- AOC@data[ -c(8) ]



colnames(AOC@data)[6]<-'pland_msh100'
colnames(AOC@data)[7]<-'ed_msh100'
colnames(AOC@data)[8]<-'pland_msh1km'

colnames(AOC@data)[9]<-'npch_bh100'
colnames(AOC@data)[10]<-'pland_bh100'
colnames(AOC@data)[11]<-'pcha_bh100'
colnames(AOC@data)[12]<-'npch_bh1km'
colnames(AOC@data)[13]<-'pland_bh1km'
colnames(AOC@data)[14]<-'pcha_bh1km'



#Append rest of values to points
rs <- stack(elev100m, elev1km, openw100, openw1km, urb100, urb1km)

e = data.frame(extract(rs, AOC))
AOC@data = data.frame(AOC@data, e[match(rownames(AOC@data), rownames(e)),])


setwd("E:\\FinalModels\\Predictors\\AOC")
writeOGR(AOC,".","AOC",driver="ESRI Shapefile")
df<-as.data.frame(AOC@data)
write.csv(df, 'AOC.csv')

AOC<-readOGR(dsn="E:\\FinalModels\\Predictors\\AOC\\AOC.shp")
df<-read.csv('AOC.csv')


#various plotting

library(reshape)
long <- melt(df[,7:16])

ggplot(long, aes(value))+
  geom_density()+
  facet_wrap(~variable)

plot(density(df$pland_marsh100))
min(df$pland_marsh100)

#plot kernal density to compare PA
library("sm")

#green == 1
#red == 0
sm.density.compare(df$urb1kmf, df$PA, xlab="dist urb (1km)")
sm.density.compare(df$urb100mf, df$PA, xlab="dist urb (100m)")
sm.density.compare(df$elev100mf, df$PA, xlab="elev (100m)",xlim=c(0,70))
sm.density.compare(df$elev1kmf, df$PA, xlab="elev (1km)",xlim=c(0,70))
sm.density.compare(df$ow100mf, df$PA, xlab="distow (100m)")
sm.density.compare(df$ow1kmf, df$PA, xlab="distow (1km)")
sm.density.compare(df$ed_msh100, df$PA, xlab="ed marsh (100m)")
sm.density.compare(df$pland_msh1km, df$PA, xlab="percent marsh (1km)",xlim=c(0,1))
sm.density.compare(df$pland_msh100, df$PA, xlab="percent marsh (100m)",xlim=c(0,1))
sm.density.compare(df$npch_bh100, df$PA, xlab="npatch beach 100m")
sm.density.compare(df$npch_bh1km, df$PA, xlab="npatch beach 1km")
sm.density.compare(df$pland_bh100, df$PA, xlab="percent beach 100m",xlim=c(0,1))
sm.density.compare(df$pland_bh1km, df$PA, xlab="percent beach 1km",xlim=c(0,1))
sm.density.compare(df$pcha_bh100, df$PA, xlab="patch area beach 100m")
sm.density.compare(df$pcha_bh1km, df$PA, xlab="patch area beach 1km")


names(df)
spearmanR <- cor(df[,7:21], method="spearman")
symnum(spearmanR)
mat<-round(cor(df[,7:21], method="spearman"), 3)
corrplot(mat, method='number')




###########################Stage 1
#sort through predictors for individual landclasses to determine neighborhood size/dominant variables


##Beach
lr01<- glm(PA ~ npch_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr02<- glm(PA ~ npch_bh1km, family=binomial(link="logit"), df, na.action=na.pass)
lr03<- glm(PA ~ pland_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr04<- glm(PA ~ pland_bh1km, family=binomial(link="logit"), df, na.action=na.pass)
lr05<- glm(PA ~ pcha_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr06<- glm(PA ~ pcha_bh1km, family=binomial(link="logit"), df, na.action=na.pass)
null <- glm(PA ~ 1, df, family = "binomial")

lrModels<- list(lr01, lr02, lr03, lr04, lr05, lr06, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "Model3", "Model4", "Model5", "Model6", "null")
#Calc AICc table
aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt

#test out a few more combinations
lr01<-glm(PA ~ pland_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr02<-glm(PA ~ pcha_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr03<-glm(PA ~ pcha_bh100 + pland_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lr04<-glm(PA ~ pcha_bh100:pland_bh100, family=binomial(link="logit"), df, na.action=na.pass)
lrModels<- list(lr01, lr02, lr03, lr04, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "Model3", "Model4", "null")
#Calc AICc table
aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt
#stick with singular variable, plandbeach 100m


##Marsh (for foraging/nesting)
#Virzi et al 2017 suggested low/intermediate marsh edge
lr01<- glm(PA ~ ed_msh100, family=binomial(link="logit"), df, na.action=na.pass)
#lr02<- glm(PA ~ ed_msh1km, family=binomial(link="logit"), df, na.action=na.pass) #I'm suspicious about this one
lr05<- glm(PA ~ pland_msh100, family=binomial(link="logit"), df, na.action=na.pass)
lr06<- glm(PA ~ pland_msh1km, family=binomial(link="logit"), df, na.action=na.pass)
null <- glm(PA ~ 1, df, family = "binomial")
lrModels<- list(lr01,lr05, lr06, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "Model5", "Model6", "null")
#Calc AICc table
aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt
#stick with singular variable, ed marsh 100m ##double check this

##Urbanization (likely impacts availability of beach, where they're spotted)
lr01<- glm(PA ~ urb100mf, family=binomial(link="logit"), df, na.action=na.pass)
lr02<- glm(PA ~ urb1kmf, family=binomial(link="logit"), df, na.action=na.pass)

lrModels<- list(lr01, lr02, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "null")
#Calc AICc table

aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt
#stick with singular variable, urb 1km


##Distance to Open water (need for foraging)
lr01<- glm(PA ~ ow100mf, family=binomial(link="logit"), df, na.action=na.pass)
lr02<- glm(PA ~ ow1kmf, family=binomial(link="logit"), df, na.action=na.pass)

lrModels<- list(lr01, lr02, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "null")
#Calc AICc table

aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt
#stick with singular variable, ow 1km

#Elevation 
#Lauro + Burger (1988) suggested that AOC may select between a threshold of Elevs
lr01<- glm(PA ~ elev100mf, family=binomial(link="logit"), df, na.action=na.pass)
lr02<- glm(PA ~ elev1kmf, family=binomial(link="logit"), df, na.action=na.pass)
lr03<- glm(PA ~ elev100mf + I(elev100mf^2), family=binomial(link="logit"), df, na.action=na.pass)
lr04<- glm(PA ~ elev1kmf + I(elev1kmf^2), family=binomial(link="logit"), df, na.action=na.pass)

lrModels<- list(lr01, lr02, lr03, lr04, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model1", "Model2", "Model3", "Model4", "null")
#Calc AICc table
aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt
#stick with singular variable, elev 1km

#pland_beach100
#ed_marsh100m ##update 8/25
#urb1kmf
#ow1kmf
#elev1kmf

###########################Stage 2
#test predictors for correlations
#test various combinations of models

library(dplyr)
pred <- df %>% select("PA", "pland_bh100","ed_msh1km","urb1kmf","ow1kmf","elev1kmf")
mat<-round(cor(pred[,2:6], method="spearman"), 3)
mat
corrplot(mat, method='number')

#NOTE: remember that names must match the rasters and columns used in model
##MANUALLY ADDED AFTER MODEL SELECTION; note that this was done 8/24


#distance to ow/mean elev are positively correlated, not surprising
#do not include in same models

#lr01<- glm(PA ~ pland_beach100 + ed_marsh1km + I(ed_marsh1km^2) + urb1kmf + ow1kmf + elev1kmf, family=binomial(link="logit"), df, na.action=na.pass) #'global model' 
#lr01 contains correlated factors
lr02<- glm(PA ~ pland_bh100 + ed_msh1km  + urb1kmf + ow1kmf, family=binomial(link="logit"), df, na.action=na.pass) 
lr04<- glm(PA ~ pland_bh100 + ed_msh1km  + urb1kmf + elev1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no ow 
lr05<- glm(PA ~ pland_bh100 + ed_msh1km  + urb1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no elev/ow 
lr06<- glm(PA ~ pland_bh100 + ed_msh1km  + elev1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no urb, leave elev
lr07<- glm(PA ~ pland_bh100 + ed_msh1km + ow1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no urb, leave ow
lr08<- glm(PA ~ pland_bh100 + urb1kmf  + elev1kmf, family=binomial(link="logit"), df, na.action=na.pass)#no ed marsh, leave elev
lr09<- glm(PA ~ pland_bh100 + urb1kmf  + ow1kmf, family=binomial(link="logit"), df, na.action=na.pass)#no ed marsh, leave ow
lr10<- glm(PA ~ pland_bh100 + ed_msh1km + urb1kmf  + elev1kmf + pland_beach100:urb1kmf, family=binomial(link="logit"), df, na.action=na.pass)#interaction of % beach + urban, no ow
lr11<- glm(PA ~ pland_bh100 + ed_msh1km, family=binomial(link="logit"), df, na.action=na.pass)#no urb, elev, ow
null <- glm(PA ~ 1, df, family = "binomial")

lrModels<- list(lr02, lr04, lr05, lr06, lr07, lr08,  lr09, lr10, lr11, null)
summ<-lapply(lrModels,summary)
summ
lrNames <- c("Model2", "Model4", "Model5", "Model6", "Model7","Model8", "Model9","Model10","Model11","null")
#Calc AICc table
aicWt<-aictab(cand.set=lrModels, modnames=lrNames, sort=TRUE, c.hat=1)
#Look at table of aic weights
aicWt

#mod 2, old mod 10 (with original interaction)
#lr02<- glm(PA ~ pland_beach100 + ed_marsh1km + I(ed_marsh1km^2) + urb1kmf + ow1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no elev 
#lr10<- glm(PA ~ pland_beach100 + ed_marsh1km + I(ed_marsh1km^2) + urb1kmf  + ow1kmf + pland_beach100:urb1kmf, family=binomial(link="logit"), df, na.action=na.pass)
#lrModels<- list(lr02, lr10)
#summ<-lapply(lrModels,summary)
#summ
#interaction factor basically insignificant

#best model for AOC
################UPDATE 8/24, trying with smaller window size for ED marsh (too large before?)
#compare pland marsh at 1km to see if that has stronger influence
lr02<- glm(PA ~ pland_bh100 + ed_msh100 + urb1kmf + ow1kmf, family=binomial(link="logit"), df, na.action=na.pass) #no elev 

#internal validation
opt.cut = function(perf, pred){
  cut.ind = mapply(FUN=function(x, y, p){
    d = (x - 0)^2 + (y-1)^2
    ind = which(d == min(d))
    c(sensitivity = y[[ind]], specificity = 1-x[[ind]], 
      cutoff = p[[ind]])
  }, perf@x.values, perf@y.values, pred@cutoffs)
}

iter <- 100         #iterations
K <- 4                #folds
perf.list <- list()
perf <- data.frame(iteration=rep(1:iter,times=K),k=rep(1:K,each=iter),AUC=NA,sens=NA,spec=NA,TSS=NA,cutoff=NA)
for (i in 1:iter){
  folds <- createFolds(df$PA, k = K, list = TRUE, returnTrain = TRUE)
  for (k in 1:K){
    j <- i + iter*(k-1)  #keeps running count to use as index in output dataframe
    pred <- predict(lr02, df[-folds[[k]],], type = "response")
    pred.lab <- as.data.frame(cbind(pred,df$PA[-folds[[k]]]))
    colnames(pred.lab) <- c("predictions","labels")
    pred.lab1 <- prediction(pred.lab$predictions,pred.lab$labels) 
    perf.auc <- performance(prediction(pred, df$PA[-folds[[k]]]),"auc")
    perf.roc <- performance(pred.lab1, measure = "tpr", x.measure = "fpr")
    perf.sens <- performance(prediction(pred,df$PA[-folds[[k]]]), "sens","spec")
    cutoff <- opt.cut(perf.roc, pred.lab1)
    perf$AUC[j] <- perf.auc@y.values[[1]] # AUC
    perf$sens[j] <- cutoff["sensitivity",] # sensitivity
    perf$spec[j] <- cutoff["specificity",] # specificity
    perf$cutoff[j] <- cutoff["cutoff",] # optimal cutoff
    perf$TSS[j] <- perf$sens[j] + perf$spec[j] - 1
  }
}

plot(density(perf$cutoff))
plot(density(perf$AUC))

abline(v=mean(perf$cutoff),lty=2,lwd=2,col="red")
opt.cutoff <- mean(perf$cutoff) 


setwd("E:\\FinalModels\\Predictors\\AOC\\beachflat\\fragstats\\beach100")
pland_bh100<-raster("pland_bh100")
plot(pland_beach100)
setwd("E:\\FinalModels\\Predictors\\AOC\\openwater\\distance\\fin")
ow1kmf<-raster("ow1kmf")
plot(ow1kmf)
setwd("E:\\FinalModels\\Predictors\\AOC\\urbanization\\distance\\fin")
urb1kmf<-raster("urb1kmf")
plot(urb1kmf)
setwd("E:\\FinalModels\\Predictors\\AOC\\marsh\\fragstats\\marshbase_tested")
ed_msh100<-raster("ed_msh100")
plot(ed_marsh100)

#recall that all raster names MUST match names of input variables to the T
require(raster)
rs<-stack(pland_bh100, urb1kmf, ow1kmf, ed_msh100)
names(rs)
AOC_pred <- predict(rs, lr02, type="response", progress='text', na.action = na.omit, overwrite=T)
plot(AOC_pred)

setwd("E:\\FinalModels\\Predictors\\AOC")
writeRaster(AOC_pred,'AOC_predsmM',format='GTiff', overwrite=T)

#LOOKS GREAT: modify script and update methods writing to reflect this
#ED marsh was too large, I think it was throwing the whole thing off

df$fitted<-fitted(lr09)
( lrAUC<- auc(df$PA, df$fitted) )
#Generate data for ROC analysis and plot it
pred <- prediction(df$fitted, df$PA)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, col=rainbow(10),main='ROC Curve, GT 2010')

#calculate max sensitivty/specificity intersection as cutoff point
sens<-performance(pred,measure='sens',x.measure = 'cutoff')
spec<-performance(pred,measure='spec',x.measure = 'cutoff')
SensSpec.model.RM <- performance(pred,  "sens", "spec")
CP<-SensSpec.model.RM@alpha.values[[1]][which.max(SensSpec.model.RM@x.values[[1]]+SensSpec.model.RM@y.values[[1]])]
both.eq <- which.min(abs(sens@y.values[[1]]-spec@y.values[[1]]))
CP<-sens@x.values[[1]][both.eq]
CP
#0.311



